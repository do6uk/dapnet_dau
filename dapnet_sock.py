#!/usr/bin/env python3

# copyright (c) 2022 by Rainer Fiedler DO6UK
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

import sys,socket,re,time,signal
from queue import Queue
from threading import Thread

# blacklist some rics - i will block all rics, which are generated by fake-core
ric_blacklist = [8,208,224,200,216,2504] 

# use unix-socket to submit messages to fake-core
server_message_socket = '/tmp/dapnet_dau.s'

# enable debugging (more useless information at console ;-)
debug = False

# enable silentmode (mostly no output) can be reached by --silent in cli
silent = False


### do not edit below this line

version = '20221205'

MULTIMON = re.compile(r'^POCSAG1200:\sAddress:\s+(\d+)\s+Function:\s+(\d)\s+(Alpha|Numeric):\s+(.+)')

message_queue = Queue()
running = True

que_handler = None
stdin_read = None

print('[dau_receiver]','starting dapnet_receiver v%s ...'%version)

if '--silent' in sys.argv:
	if debug: print('[dau_receiver]','running silent mode will set  debug = False')
	silent = True
	debug = False

def clean_message(msg):
	remove = ['DEL','NUL','DLE','SOH','DC','STX','ETX','EOT','ENQ','NAK','ACK','SYN','BEL','ETB','BS','CAN','HT','EM','LF','SUB','VT','ESC','FF','FS','CR','GS','SO','RS','SI','US']
	for char in remove:
		msg = msg.replace('<{}>'.format(char),'')
	
	return msg

def handle_queue():
	global running, message_queue
	
	conn_attemp = 0
	sock_connect = False
	while running:
		if not message_queue.empty():
			unix_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
			try:
				conn_attemp += 1
				unix_socket.connect(server_message_socket)
				if debug: print('[SOCK]','connected')
				conn_attemp = 0
				sock_connect = True
			except ConnectionRefusedError:
				if not silent: print('[SOCK]','not connected - retry ...')
				time.sleep(3)
				sock_connect = False
				
				if conn_attemp >= 3:
					# clear queue
					if conn_attemp == 3 or debug:
						if not silent: print('[SOCK]','too many attemps to connect - dropping queue ...')
					message_queue.queue.clear()

				continue
			
			while not message_queue.empty() and sock_connect:
				message = message_queue.get()
				if not silent: print('[SOCK]','MSG',message)
				try:
					unix_socket.sendall(message.encode('utf-8'))
					if debug: print('[SOCK]','MSG send')
				except BrokenPipeError:
					try:
						sock_connect = False
						unix_socket.connect(server_message_socket)
						unix_socket.sendall(message.encode('utf-8'))
						if not silent: print('[SOCK]','MSG send retry')
					except:
						sock_connect = False
						break
				
				try:
					data = unix_socket.recv(1024).decode('utf-8')
					if data[0] == '+':
						if debug: print('[SOCK]','MSG ACK')
					else:
						if debug: print('[SOCK]','received invalid response',data.rstrip())
				except ConnectionResetError:
					print('[SOCK]','connection reset - retry ...')
					try:
						unix_socket.connect(server_message_socket)
						unix_socket.sendall(message.encode('utf-8'))
					except ConnectionRefusedError:
						sock_connect = False
						break
					except:
						sock_connect = False
						break
				
				time.sleep(0.1)
				
			sock_connect = False
			unix_socket.close()
			if debug: print('[SOCK]','closed')

		time.sleep(0.1)

def signal_handler(signum,frame):
	global running, debug
	
	# SIGTERM, SIGKILL
	
	if signum == signal.SIGTERM:
		if not silent: print('[dau_receiver]','SIGTERM received ...')
		clean_exit()

	return

def clean_exit():
	global running, que_handler, stdin_read
	
	print('[dau_receiver]','request shutdown ...')
	
	running = False
	
	if debug: print('[dau_receiver]','waiting for STDIN ...')
	stdin_read.join(5)
	time.sleep(1)
	if debug: print('[dau_receiver]','waiting for QUEUE ...')
	que_handler.join(5)
	time.sleep(1)

	if debug: print('[dau_receiver]','ready to exit')
	
	return

def read_stdin():
	global running, que_handler, message_queue, ric_blacklist

	while running:
		for line in sys.stdin:
			if not running: break
			
			line_data = line.rstrip()
			if debug: print('[STDIN]','received data',line_data)
			
			# parse data
			match_data = MULTIMON.match(line_data)
			if match_data:
				m_speed = 1
				m_ric = int(match_data[1])
				m_function = int(match_data[2])
				m_type = match_data[3]
				message = clean_message(match_data[4])
				if debug: print('[STDIN]','MSG:',m_ric,m_function,m_type,message)
				
				if m_type.lower() == 'alpha':
					m_type = 6
				elif m_type.lower() == 'numeric':
					m_type = 5
				else:
					m_type = 0
					
				if not m_ric in ric_blacklist:
					data = '{:1}:{:1}:{}:{:1}:{}'.format(m_type,m_speed,m_ric,m_function,message)
					message_queue.put(data)
				else:
					if not silent: print('[STDIN]','message dropped - address blacklisted',m_ric)
			else:
				if debug: print('[STDIN]','received invalid message',line_data)
				pass
	
	return


# register sig_handle
signal.signal(signal.SIGTERM, signal_handler)

# create que_handler
if debug: print('[dau_receiver]','init message handler ...')
que_handler = Thread(target=handle_queue)
que_handler.start()

try:
	if debug: print('[dau_receiver]','init main loop ...')

	if running:
		if debug: print('[dau_receiver]','init parsing stdin ...')
		stdin_read = Thread(target=read_stdin)
		stdin_read.daemon = True
		stdin_read.start()
	
	while running:
		time.sleep(0.1)

except KeyboardInterrupt:
	print('[dau_receiver]','user interrupt CTRL-C')
	clean_exit()

if debug: print('[dau_receiver]','cleanly closed !')
sys.exit(0)